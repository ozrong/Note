# 为什么int数组就不可以直接输出而char数组就可以直接输出

```java
 char[] a = new char[]{'s','b'};
  System.out.println(a); //sb


 int[] b = new int[]{1,2,3,4,5};
  System.out.println(b); //[I@1540e19d


why？？？？（结果表明我们可以直接整体输出字符型数组和字符串，而无法整体输出整形数组(只能输出其地址)为什么会这样呢？？？？？？？？？？？？）
    
    打印的时候这两个println（）是不一样的。
    打印Int数组使用的是：
        public void println(Object x) {
        String s = String.valueOf(x);
        synchronized (this) {
            print(s);
            newLine();
        }
    }

	打印char数组使用的是
    public void println(char x[]) {
        synchronized (this) {
            print(x);
            newLine();
        }
    }
   
   打印int数组多了一步操作  String s = String.valueOf(x);  字符数组得到的是一个字符串 而int数组得到的是地址变成的字符串
    
    
    

```





# ArrayList

**ArrayList只是一个存放对象的容器。所以可以存放重复的数据**
**像Map中key-value那样的key不能重复，key重复的话原来的key所对应的value就被覆盖了**



**Question1: 常见的List类有哪些，它们分别有什么区别？**

**答：**常见的有ArrayList，Vector，LinkedList等。ArrayList底层是数组组成，Vector是线程安全的ArrayList类。LinkedList底层是由链表组成。ArrayList与Vector的区别，扩容上面ArrayList是扩容1.5倍，而Vector是扩容两倍。Vector是线程安全的使用synchronized关键字来保证线程安全，但是效率更低。

**Question2: ArrayList是如何增加容量的？**

**答:** 当存入数据到ArrayList中去的时候，都需要检查容量是否够，如果够的话，直接存入即可。如果不够的话，就会启动扩容机制，首先扩容至原容量的1.5倍大小，判断是否足够，如果不够就按照当前的容量扩容。当前的容量需要判断是否小于最大的容量（Integer.MAX_VALUE-8），如果不小于，则扩容至最大的容量，Integer的最大值。

**Question3：ArrayList和LinkedList在实际应用中应该如何选择？**

**答：**ArrayList实现了RandomAccess接口，支持快速随机访问，访问的速度很快，而ArrayList在增加和删除元素的时候，每次增加或者删除一个元素，由于是数组实现的，所有的数据都需要移动n次（就是用System.arrayCopy实现的），这是一种极为消耗资源的操作。但是LinkedList就不同，LinkedList底层是链表实现的，增加和删除元素较快，查找的话比较慢。所以一般在实际应用中，如果涉及到大量的查找的话，使用ArrayList，涉及到大量的增删操作的话，建议使用LinkedList。

ArrayList与LinkedList都允许存储null也允许存储重复元素。不要使用for循环遍历LinkedList，效率很低。

**Question5: Arrays.asList之后获得的集合能够扩容吗？**

**答：**不能扩容，因为这样获取到的一个集合是final的。所以不能够扩容或者修改

# Java 8 中的 Streams API

## **为什么需要 Stream**

Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。

## 什么是流

Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。

而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。Java 的并行 API 演变历程基本如下：

+ 1.0-1.4 中的 java.lang.Thread

+ 5.0 中的 java.util.concurrent

+ 6.0 中的 Phasers 等

+ 7.0 中的 Fork/Join 框架

+ 8.0 中的 Lambda

Stream 的另外一大特点是，数据源本身可以是无限的

### 流的构成

当我们使用一个流的时候，通常包括**三个基本步骤：**

获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，

## 生成 Stream

有多种方式生成 Stream Source：

- 从 Collection 和数组

  - Collection.stream()

  - Collection.parallelStream()
  - Arrays.stream(T array) or Stream.of()

- 其他（学到了在补充）

  

# 贪心算法





# String  (必须要熟悉String的方法)

## 1. charAt

```
public char charAt(int index)  返回指定位置的字符
```

## 2. StringBuffer

StringBuffer ret = new StringBuffer();

可以向python中列表一样添加字符

```java
StringBuffer ret = new StringBuffer();
ret.append("ssss");
ret.append('h');
ret.append(2);
StringBuffer kk = new StringBuffer("hahahahhahaha");
ret.append(kk);
System.out.println(ret.toString());

"""
    append() 可以添加很多东西，如下面的图 所有的应该都会转化为字符
"""
```



![image-20201125203905318](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20201125203905318.png)

## 3.toCharArray()

```java
这个函数是String类里面的，不是Arrays里面的
public char[] toCharArray()  无参数，返回字符数组;

把字符串变成字符数组   
```

##  4.基本数据型态转换成 String 的 static 方法( **String.valueOf()**)

```java
（1）String.valueOf(boolean b) : 将 boolean 变量 b 转换成字符串 
（2）String.valueOf(char c) : 将 char 变量 c 转换成字符串 
（3）String.valueOf(char[] data) : 将 char 数组 data 转换成字符串 
（4）String.valueOf(char[] data, int offset, int count) : 将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串 

（5）String.valueOf(double d) : 将 double 变量 d 转换成字符串 
（6）String.valueOf(float f) : 将 float 变量 f 转换成字符串 
（7）String.valueOf(int i) : 将 int 变量 i 转换成字符串 
（8）String.valueOf(long l) : 将 long 变量 l 转换成字符串 
（9）String.valueOf(Object obj) : 将 obj 对象转换成 字符串, 等于 obj.toString() 
```

## 5.String 转 int

1、String 转 int 方法1，使用Integer类中的parseInt（）方法。

```java
String str = "10";
int number = Integer.parseInt(str)
```

2、String 转 int 方法2，使用Integer类中的valueOf()和intValue()方法

```java
String str = "10";
 int a =Integer.valueOf(str).intValue()
```

**注意：String 转int要注意的是，因为可能字符串种存在非数字，因此要抛异常**

## 6. 字符串的长度是可以直接得到的

```java
        String pattern = "sdsdsds";
        System.out.println(pattern.length()); // 7

```



# Arrays

## Arrays.asList与Arrays.stream

Arrays.asList 将数组转化为list

```java
List list = Arrays.asList("a","ab","abc");
list.clear(); //报错
list.remove("a");//报错
list.add("g");//报错

这是因为使用这种方式初始化的List是不能改变的
```

Arrays.stream将数组转换成流



**注意 **    Arrays.asList() 转换非基本类型的还可以，但是基本类型就不行

```java
eg:
        String pattern = "sdsdsds";
        char[] aa = pattern.toCharArray();
        System.out.println(Arrays.asList(aa));//[[C@1540e19d] （地址）


        int[] a = {1,2,3,4};
        System.out.println(Arrays.asList(a));//[[I@677327b6]




```



## Arrays.sort

Arrays.sort(int[] a)      这种形式是对一个数组的所有元素进行排序, 从小到大的顺序

Arrays类的sort()方法是对一个数组进行排序的方法，sort()方法的参数是一个对象数组，也就是要排序的那个数组，**但是有些特别的是，这个对象数组中存储的对象的类必须实现了Comparable接口**

## Arrays.toString

这个是直接在原数值进行操作的，没有返回值。

这有个坑

```java
eg1: 
		char[] a = new char[]{'0','1'}; 
		String str = Arrays.toString(a);
		System.out.println(str);  //[0, 1]

eg2:
        char[] a = new char[]{'s','b'};
        String str = Arrays.toString(a);
        System.out.println(str); //[s, b]
toString 会添加"[]" ,并不是把数组给放在了一起变成“01”或者“sb”;

想要达到这样的目的有两种方法：
    方法一：
    
    遍历这个数组
        String ans1 = "";
        for (char c : a){
            ans1 = ans1+c;
        }
   方法二：
        String str = String.valueOf(a);
      


    

```



# Map接口

## HashMap

HashMap是[Map接口](https://www.baidu.com/s?wd=Map接口&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的主要实现类

### getOrDefault()

当Map集合中有这个key时，就使用这个key值；
如果没有就使用默认值defaultValue.

```java
eg:

        Map<String,String> map = new HashMap<>();
        map.put("one","1");
        map.put("two","2");

        String key = map.getOrDefault("one","hahha");
        System.out.println(key);//1

        String key2 = map.getOrDefault("three","yayaya"); //注意：这个key “three”和value “yayaya”都不会添加到Map中
        System.out.println(key2);//yayaya

		System.out.println(map);//{one=1, two=2}




显然getOrDefault()是如果Map中有这个key则返回对应的值，如果没有则返回设置的默认值。
注意的是：这个值并没有添加到Map中

```





# java链表

```java
链表结构;
class NodeList{
    int val;
    NodeList next;
    NodeList (int val){
        this.val = val;
    }
}
以上就是一个链表类;

NodeList head = new NodeList(23);
NodeList frist = new NodeList(25);

head.next = frist; //这就连接起来了
```

