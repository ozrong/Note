# [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}
    
    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _left, Node _right, Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
*/

class Solution {
    public Node connect(Node root) {
        if (root == null) {
            return root;
        }
   
        // 初始化队列同时将第一层节点加入队列中，即根节点
        Queue<Node> queue = new LinkedList<Node>(); 
        queue.add(root);
        
        // 外层的 while 循环迭代的是层数
        while (!queue.isEmpty()) {
            
            // 记录当前队列大小
            int size = queue.size();
            
            // 遍历这一层的所有节点
            for (int i = 0; i < size; i++) {
                
                // 从队首取出元素
                Node node = queue.poll();
                
                // 连接
                if (i < size - 1) {
                    node.next = queue.peek();
                }
                
                // 拓展下一层节点
                if (node.left != null) {
                    queue.add(node.left);
                }
                if (node.right != null) {
                    queue.add(node.right);
                }
            }
        }
        
        // 返回根节点
        return root;
    }
}

```

# [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

自己的错误代码：

```java
class Solution {
    public void reorderList(ListNode head) {
        ListNode begin = head;
        while (head !=null && head.next!=null){
            ListNode first = head;
            head = head.next;
            ListNode temp = head;
            while (true){
                if(temp!=null && temp.next!=null && temp.next.next==null){
                    break;
                }else{
                    temp = temp.next;
                }
            }
            ListNode end = temp.next;
            temp.next=null;

            first.next = end;
            end.next = head;
        }
        head = begin; 
        return head;
    }
}
绝对可行，下次再调
```

思路：    
    1.快慢指针找到中点 2.拆成两个链表 3.遍历两个链表，后面的塞到前面的“缝隙里”
    

方法一：

因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。

因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        List<ListNode> list = new ArrayList<ListNode>();
        ListNode node = head;
        while (node != null) {
            list.add(node);
            node = node.next;
        }
        int i = 0, j = list.size() - 1;
        while (i < j) {
            list.get(i).next = list.get(j);
            i++;
            if (i == j) {
                break;
            }
            list.get(j).next = list.get(i);
            j--;
        }
        list.get(i).next = null;
    }
}
这个方法最简单
```

方法二：

方法二：寻找链表中点 + 链表逆序 + 合并链表
注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果。

这样我们的任务即可划分为三步：

+ 找到原链表的中点（参考[876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)）。

我们可以使用快慢指针来 O(N)O(N) 地找到链表的中间节点。

+ 将原链表的右半端反转（参考[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)）。

我们可以使用迭代法实现链表的反转。

+ 将原链表的两端合并。

因为两链表长度相差不超过 1，因此直接合并即可。

```java
class Solution {
    public void reorderList(ListNode head) {
        if (head == null) {
            return;
        }
        ListNode mid = middleNode(head);
        ListNode l1 = head;
        ListNode l2 = mid.next;
        mid.next = null;
        l2 = reverseList(l2);
        mergeList(l1, l2);
    }

    public ListNode middleNode(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        while (curr != null) {
            ListNode nextTemp = curr.next;
            curr.next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }

    public void mergeList(ListNode l1, ListNode l2) {
        ListNode l1_tmp;
        ListNode l2_tmp;
        while (l1 != null && l2 != null) {
            l1_tmp = l1.next;
            l2_tmp = l2.next;

            l1.next = l2;
            l1 = l1_tmp;

            l2.next = l1;
            l2 = l2_tmp;
        }
    }
}
```

# [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。

注意：
总人数少于1100人。

示例

```
输入:
[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]

输出:
[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]
```

```java
有点难
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        //首先对数组进行排序（按第一个关键字升序，第二个关键字降序）
        Arrays.sort(people, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[0] != o2[0]){
                    return o1[0]-o2[0];////返回0则o1和o2的位置不变，返回负数也不变，返回正数则交换位置
                }else{
                    return o2[1]-o1[1];
                }
            }
        });
        int n = people.length;
        int[][] ans = new int[n][];
        for(int[] person:people){
            int space = person[1]+1;
            for (int i = 0; i <n ; i++) {
                if(ans[i] == null){
                    --space;
                    if(space == 0){
                        ans[i] = person;
                        break;
                    }
                }
            }
        }
        return ans;
    }
}
```



## 比较器（Comparator）

对数组或者List列表，或者Map(非hash)等排序是我们经常使用的一种处理数据的手段

Comparator接口是java中很方便的一个接口

我们只需要重写compare方法即可实现排序

int compare(Object o1, Object o2) 返回一个基本类型的整型
如果要按照升序排序，
则o1 小于o2，返回-1（负数），相等返回0，o1大于o2返回1（正数）

如果要按照降序排序
则o1 小于o2，返回1（正数），相等返回0，o1大于o2返回-1（负数）



**换一个说法： 想要升序就使用前一个减后一个，想要降序就用后一个减前一个**

使用方法：

```java
新建比较器并重写compare方法;
Comparator<User> comp=new Comparator<User>(){
    //升序
    public int compare(User o1,User o2){
        if(o1.getAge()>o2.getAge()){
            return 1;
        }else if(o1.getAge()==o2.getAge()){
            return 0;
        }else{
            return -1;
        }                   
    }
    
也可以新建内部类或者外部类如下
  public class UserAgeComparator implements Comparator<User> {  
         //升序
			public int compare(User o1,User o2){
				if(o1.getAge()>o2.getAge()){
                                     return 1;
                                 }else if(o1.getAge()==o2.getAge()){
                                      return 0;
                                 }else{
                                   return -1;
                                 }                   
			   }
}

    
        
使用比较器：
    users是可以排序的对象
    1.直接使用
    	Collections.sort(users,comp);	
                Collections.reverse(users);//反转排序
   2.用class继承就先实例化class
         UserAgeCompartor mc = new UserAgeCompartor ();
                Collections.sort(list, mc);
    
    
    
Eg:::
    
    public static void main(String[] args) {
        Integer[] a =new Integer[]{2,5};
        Arrays.sort(a, new Comparator<Integer>() {//泛型里面装的对象（封装类）
            @Override
            public int compare(Integer o1, Integer o2) {
                if (o1 != o2){
                    return  (o1-o2);
                }else{
                    return 0;
                }
            }
        });
        System.out.println(Arrays.toString(a));
    }
```

# [134. 加油站](https://leetcode-cn.com/problems/gas-station/)

```java
//在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 
//
// 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 
//
// 如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。 
//
// 说明: 
//
// 
// 如果题目有解，该答案即为唯一答案。 
// 输入数组均为非空数组，且长度相同。 
// 输入数组中的元素均为非负数。 
// 
//
// 示例 1: 
//
// 输入: 
//gas  = [1,2,3,4,5]
//cost = [3,4,5,1,2]
//
//输出: 3
//
//解释:
//从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
//开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
//开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
//开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
//开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
//开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
//因此，3 可为起始索引。 
//
// 示例 2: 
//
// 输入: 
//gas  = [2,3,4]
//cost = [3,4,3]
//
//输出: -1
//
//解释:
//你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
//我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
//开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
//开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
//你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
//因此，无论怎样，你都不可能绕环路行驶一周。 
// Related Topics 贪心算法


import java.util.concurrent.ForkJoinPool;

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int len = gas.length;
        int begin = 0;
        int index = -1;
        int flag = 0;
        for (int k = 0; k < len; k++) {
            if ((gas[k] - cost[k]) >= 0) {
                index = k;

                for (int i = k; i < len; i++) {
                    if (index == i && flag == 1) return index;
                    begin = begin + gas[i];
                    begin = begin - cost[i];
                    if (begin < 0) {
                        begin = 0;
                        index = -1;
                        flag = 0;
                        break;
                    }
                    if ((i+1)==len) {
                        i = -1;
                        flag = 1;
                    }
                }
            }
    }
        return -1;
        }

    }
//leetcode submit region end(Prohibit modification and deletion)
效率太低了
```

**方法二：**

题解：
    这个图是从0点（i=0,即第一个站）出发的折线图，那么改变出发点时，这个图会怎么变化呢？你可以自己去画一画，你会发现，整体折线图的形状是没有变的，改变的是y值，相当于将折线图在Y轴方向上上下平移。那么，当最小点落在X轴上时（也就是使得最小点y=0时），整体折线在X轴上方，y值恒大于等于0，也就是剩余油量一直不为负，可以绕行一圈。对于本例，也就是使得i=3时，y=0。此时，意味着从i=3，第四个站出发，到此站时即没有加油也没有耗油，剩余油量为0



也就是说从某个起点到在回到某个起点这个油的剩余是要一直都是大于等于0的。



![image-20201119084755411](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20201119084755411.png)



```java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int len = gas.length;
    int spare = 0;
    int minSpare = Integer.MAX_VALUE;
    int minIndex = 0;

    for (int i = 0; i < len; i++) {
        spare += gas[i] - cost[i];
        if (spare < minSpare) {
            minSpare = spare;
            minIndex = i;
        }
    }

    return spare < 0 ? -1 : (minIndex + 1) % len;
}
```

## %运算符

把自己搞蒙了，%是取模运算（取余）不是取小数

# [452. 用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

```java
//在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横
//坐标就足够了。开始坐标总是小于结束坐标。 
//
// 一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xsta
//rt ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的
//最小数量。 
//
// 给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。 
// 
//
// 示例 1： 
//
// 
//输入：points = [[10,16],[2,8],[1,6],[7,12]]
//输出：2
//解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球 
//
// 示例 2： 
//
// 
//输入：points = [[1,2],[3,4],[5,6],[7,8]]
//输出：4
// 
//
// 示例 3： 
//
// 
//输入：points = [[1,2],[2,3],[3,4],[4,5]]
//输出：2
// 
//
// 示例 4： 
//
// 
//输入：points = [[1,2]]
//输出：1
// 
//
// 示例 5： 
//
// 
//输入：points = [[2,3],[2,3]]
//输出：1
// 
//
// 
//
// 提示： 
//
// 
// 0 <= points.length <= 104 
// points[i].length == 2 
// -231 <= xstart < xend <= 231 - 1 
// 
// Related Topics 贪心算法 排序


//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int findMinArrowShots(int[][] points) {
        int min = 0;
        int len =points.length;
        List<Integer[]> temp = new ArrayList<>();
        for (int i = 0; i <len ; i++) {
            Integer[] t = new Integer[]{points[i][0],points[i][1]};
            temp.add(t);
        }
        while (!temp.isEmpty()) {
            if(temp.size()==1){
                min = min+1;
            }
            Integer[] one = temp.get(0);
            for (int i = 1; i <temp.size() ; i++) {
                Integer[] next = temp.get(i);
                if((one[0] <=next[0]  && one[1] >= next[0]) || (next[0] <= one[0] && next[1] >=one[0])){
                    temp.remove(next);
                }
            }
            min++;

        }
        return min;
    }
}
超时------------------
//leetcode submit region end(Prohibit modification and deletion)

```

```java
两个是一样的原理：排序的写法不一样
class Solution {
    public int findMinArrowShots(int[][] points) {
        if (points.length == 0) {
            return 0;
        }
        Arrays.sort(points, new Comparator<int[]>() {
            public int compare(int[] point1, int[] point2) {
                if (point1[1] > point2[1]) {
                    return 1;
                } else if (point1[1] < point2[1]) {
                    return -1;
                } else {
                    return 0;
                }
            }
        });
        int pos = points[0][1];
        int ans = 1;
        for (int[] balloon: points) {
            if (balloon[0] > pos) {
                pos = balloon[1];
                ++ans;
            }
        }
        return ans;
    }
}

+++++++++++++++++++++++++++++++++++这是分界线++++++++++++++++++++++++++++++++
    
    

class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points.length == 0) return 0;
        Arrays.sort(points, (p1, p2) -> p1[1] < p2[1] ? -1 : 1);lambda表达式
        int res = 1;
        int pre = points[0][1];
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > pre) {
                res++;
                pre = points[i][1];
            }
        }
        return res;

    }
}


```

## lambda

# [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)（太难了）（没做起）

绝对可以用递归

```java
果然
    class Solution {
    public int countNodes(TreeNode root) {
    	if(root == null) {
    		return 0;
    	}
    	int left = countNodes(root.left);
    	int right = countNodes(root.right);
    	
    	return left+right+1;
    	
    }
}    
```



## 树的知识

## 完全二叉树

当 $0<=i<=h$时，第$ i$层包含$2^i$个节点，最底层包含的节点数最少为 1，最多为$2^h$

当最底层包含 1个节点时，完全二叉树的节点个数是
$$
\sum_{i=0}^{h-1} 2^{i}+1=2^{h}
$$
当最底层包含$2^h$个节点时，完全二叉树的节点个数是
$$
\sum_{i=0}^{h} 2^{i}=2^{h+1}-1
$$
因此对于最大层数为 hhh 的完全二叉树，节点个数一定在$\left[2^{h}, 2^{h+1}-1\right]$ 的范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数

## 二分查找

## 位运算

# [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

**方法1 暴力解法**

```java
//给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[
//l] = 0。 
//
// 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最
//终结果不会超过 231 - 1 。 
//
// 例如: 
//
// 
//输入:
//A = [ 1, 2]
//B = [-2,-1]
//C = [-1, 2]
//D = [ 0, 2]
//
//输出:
//2
//
//解释:
//两个元组如下:
//1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
//2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
// 
// Related Topics 哈希表 二分查找


//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
        int len_A =A.length;
        int len_B =B.length;
        int len_C =C.length;
        int len_D =D.length;
        int ans =0;
        for (int i = 0; i <len_A ; i++) {
            for (int j = 0; j <len_B ; j++) {
                for (int k = 0; k <len_C ; k++) {
                    for (int l = 0; l <len_D ; l++) {
                        if (A[i] + B[j] + C[k]+D[l] == 0) {
                            ans++;
                        }
                    }
                }
            }
        }
        return ans;
    }
}
//leetcode submit region end(Prohibit modification and deletion)
超时========================================
```

**方法一：分组 + 哈希表**

我们可以将四个数组分成两部分，AAA 和 BBB 为一组，CCC 和 DDD 为另外一组。

对于 AAA 和 BBB，我们使用二重循环对它们进行遍历，得到所有 A[i]+B[j]A[i]+B[j]A[i]+B[j] 的值并存入哈希映射中。对于哈希映射中的每个键值对，每个键表示一种 A[i]+B[j]A[i]+B[j]A[i]+B[j]，对应的值为 A[i]+B[j]A[i]+B[j]A[i]+B[j] 出现的次数。

对于 CCC 和 DDD，我们同样使用二重循环对它们进行遍历。当遍历到 C[k]+D[l]C[k]+D[l]C[k]+D[l] 时，如果 −(C[k]+D[l])-(C[k]+D[l])−(C[k]+D[l]) 出现在哈希映射中，那么将 −(C[k]+D[l])-(C[k]+D[l])−(C[k]+D[l]) 对应的值累加进答案中。

最终即可得到满足 A[i]+B[j]+C[k]+D[l]=0A[i]+B[j]+C[k]+D[l]=0A[i]+B[j]+C[k]+D[l]=0 的四元组数目

```java
class Solution {
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
        int len_A =A.length;
        int len_B =B.length;
        int len_C =C.length;
        int len_D =D.length;

        int ans =0;
        Map<Integer,Integer>  countAB = new HashMap<>();

        for (int i:A) {
            for (int j :B) {
                countAB.put(i+j,countAB.getOrDefault(i+j,0)+1);
                    }
                }
        for (int k:C){
            for(int l:D){
                int key = -(k+l);
                if(countAB.containsKey(key)){
                    ans+=countAB.get(key);
                }
            }
        }
        return ans;
    }
}
```

# [767. 重构字符串](https://leetcode-cn.com/problems/reorganize-string/)（有点难）（没做）

# [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)（没做）

# [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

```java
自己做的开心;
//给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 
//
// 示例: 
//
// 输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
//输出:
//[
//  ["ate","eat","tea"],
//  ["nat","tan"],
//  ["bat"]
//] 
//
// 说明： 
//
// 
// 所有输入均为小写字母。 
// 不考虑答案输出的顺序。 
// 
// Related Topics 哈希表 字符串


import java.lang.reflect.Array;
import java.util.*;

//leetcode submit region begin(Prohibit modification and deletion)
就是使用HashMap 
    2.每次判断排序后的字符串是不是HashMap的key，如果是就添加原字符串到key对应的value中（value就是一个List），否则就把排序后的字符串作为Key,再把原来的字符放进List里面做为value


class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        int len = strs.length;
        HashMap<String,List> hashMap = new HashMap<String, List>();
        List<List<String>>  ans = new ArrayList<>();
        for (int i = 0; i <len ; i++) {
            List<String> temp = new ArrayList<>();
            char[] temp_char = strs[i].toCharArray();
            Arrays.sort(temp_char);
            String temp_string = Arrays.toString(temp_char);
            if (hashMap.get(temp_string) == null) {
                temp.add(strs[i]);
                hashMap.put(temp_string,temp);
            } else {
                hashMap.get(temp_string).add(strs[i]);
            }
        }
       Iterator it =  hashMap.keySet().iterator();
       while (it.hasNext()){
           String key = (String)it.next();
           List<String> value =hashMap.get(key);
           ans.add(value);
       }
       return ans;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

```



# [738. 单调递增的数字](https://leetcode-cn.com/problems/monotone-increasing-digits/)



```java
//给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。 
//
// （当且仅当每个相邻位数上的数字 x 和 y 满足 x <= y 时，我们称这个整数是单调递增的。） 
//
// 示例 1: 
//
// 输入: N = 10
//输出: 9
// 
//
// 示例 2: 
//
// 输入: N = 1234
//输出: 1234
// 
//
// 示例 3: 
//
// 输入: N = 332
//输出: 299
// 
//
// 说明: N 是在 [0, 10^9] 范围内的一个整数。 
// Related Topics 贪心算法


思路：从后往前遍历，如果前面的值大于后面的值就把当前位数减一然后把后面所有位置的值变成9，以此类推

import java.util.Arrays;

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int monotoneIncreasingDigits(int N) {
        char[]  temp = String.valueOf(N).toCharArray();
        int len = temp.length;
        for (int i = len-1; i >=1 ; i--) {
            if (temp[i-1] > temp[i] ){
                temp[i-1] = (char)(((int)temp[i-1])-1);
                for (int j = i; j <len ; j++) {
                    temp[j] = '9'
                }
            }
        }
        String ans1 =String.valueOf(temp);

        int ans = Integer.valueOf(ans1).intValue();
        return ans;

    }
}
//leetcode submit region end(Prohibit modification and deletion)

```

# [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)(动态规划问题  做不来)

# [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)（动态规划）

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

eg:输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        if(m<=0 || n<=0) return 0;
        for(int i=0;i<m;i++){
            dp[i][0] = 1;
        }
        for(int i=0;i<n;i++){
            dp[0][i] = 1;
        }
        for (int i=1;i<m;i++){
            for (int j=1;j<n;j++){
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

# [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)(动态规划)

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m =grid.length;
        int n =grid[0].length; 
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for(int i=1;i<m;i++){
            dp[i][0] = dp[i-1][0]+grid[i][0];
        }
        for(int i=1;i<n;i++){
            dp[0][i] = dp[0][i-1]+grid[0][i];
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = grid[i][j]+Math.min(dp[i-1][j],dp[i][j-1]);
            }
        }

        return dp[m-1][n-1];

    }
}
```

# [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)(图，没做)

# [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

```java
//给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 
//
// 示例 1: 
//
// 输入: [1,2,3,4,5,6,7] 和 k = 3
//输出: [5,6,7,1,2,3,4]
//解释:
//向右旋转 1 步: [7,1,2,3,4,5,6]
//向右旋转 2 步: [6,7,1,2,3,4,5]
//向右旋转 3 步: [5,6,7,1,2,3,4]
// 
//
// 示例 2: 
//
// 输入: [-1,-100,3,99] 和 k = 2
//输出: [3,99,-1,-100]
//解释: 
//向右旋转 1 步: [99,-1,-100,3]
//向右旋转 2 步: [3,99,-1,-100] 
//
// 说明: 
//
// 
// 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 
// 要求使用空间复杂度为 O(1) 的 原地 算法。 
// 
// Related Topics 数组


//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        Map<Integer,Integer> ans = new HashMap<Integer,Integer>();
        for (int i = 0; i < len; i++) {
            /*
            使用一个HashMap来保存移动过后的位置以及对应的值
            最后在遍历这个map放入到nums中，效率有点低
            */
            int j = i;
            j = j + k;
            while (j > len - 1) {
                j = j - len;
            }
            ans.put(j, nums[i]);
        }
        for (Integer key : ans.keySet()) {
            int value = (Integer) ans.get(key);
            nums[(Integer)key] = value;
        }
    }
}

//leetcode submit region end(Prohibit modification and deletion)

```

## HashMap的遍历

在HashMap中，有一个明显的特征。在存储的时候，会有一个键值对的关系。键和值存在着一一对应（映射）的关系。而HashMap中的键相当与Set，无序不可重复。因此，在遍历的时候可以用Set集合得到HashMap中的键，然后通过Set集合得到迭代器，最后用迭代器遍历。

第一种：普遍使用，foreach来获取map的keyset再通过key取value 

```java
System.out.println("通过Map.keySet遍历key和value：");
 for (String key : map.keySet()) {
  System.out.println("key= "+ key + " and value= " + map.get(key)); 
 }
```

第二种：通过Map.entrySet使用iterator遍历key和value 

```java
System.out.println("通过Map.entrySet使用iterator遍历key和value：");
 Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();
 while (it.hasNext()) {
  Map.Entry<String, String> entry = it.next();
  System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
 }
```

第三种：通过Map.entrySet遍历key和value （推荐，尤其是容量大时） 

```java
System.out.println("通过Map.entrySet遍历key和value");
 for (Map.Entry<String, String> entry : map.entrySet()) {//一个以个Entry，是遍历不是一下获取全部
  System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
 }
```

第四种：通过Map.values()遍历所有的value，但不能遍历key

```java
System.out.println("通过Map.values()遍历所有的value，但不能遍历key");
 for (String v : map.values()) {
  System.out.println("value= " + v);
 }
}
```

# [1202. 交换字符串中的元素](https://leetcode-cn.com/problems/smallest-string-with-swaps/)（没做）

# [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)（图 没做）